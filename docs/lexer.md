扫描每个单词，进行词法分析，即对不同的语句作不同的处理，语句由正则表达式规定，处理由语句后的代码块规定。总的来说，我们需要处理这么几类语句：
    关键字，组成的字符串固定，如if, fi, else。
    整数、字符串，需要lexer记录额外信息，如整数值、字符串内容。
    释和空格，应忽略，不生成token。
    各种符号，类型名Type ID、变量名Object ID。
    非法字符。

需要处理固定字符关键字：
    通过定义tokenkine枚举类型来对token的种类进行标记，需要专门用一个TokenKind类来记录

Lexer主要包含两个单元：
1. 扫描阶段： 主要负责完成一些不需要生成词法单元的简单处理，比如删除注释和将多个连续的空白字符压缩成一个字符；
2. 词法分析阶段：较为复杂的部分，它处理扫描阶段的输出并生成词法单元。
---------------------------------------------------------------------------------
void Lexer::scanText():
逐字符扫描，用空格和换行符来分隔单词（即关键字），将所扫描到的单词均放到vector<string>容器中等待下一步处理（感觉这个容器就是初步调试作用）
11-3：应先遍历容器判断提取的关键字是否正确
---------------------------------------------------------------------------------
待完善事件：
1. 通过逐个字符扫描初步划分Token种类；
2. 添加concatenateTokens()函数用来将所划分的Token拼接起来，可以随时还原为原文本（为啥我总觉的没必要要该函数，因为只需要存储Token然后得知Token的顺序不就好啦？）
3. 移植slang的关键字对应表
4. 应该在识别出是char后，读取全部单词，在关键字对应表中进行遍历寻找
5. void Lexer::scanNumber()中不可出现多个小数点，保证整数或者小数有效性

---------------------------------------------------------------------------------
Question：
1. slang的Lexer.cpp中lexStringLiteral()是干什么的？为什么需要stringBuffer
2. 不明白slang中TokenKind的枚举内容在哪里定义啦？--使用枚举类继承uint32
3. concatenateToken连接Token的作用是什么？
4. 如何处理扫描括号类字符？
5. 如何对关键字即字符类的Token进行具体的TokenKind匹配？(已解决)
6. 如何区分字符和字符变量和普通变量？(有""的应该是字符，其他是identifier) int a; string b;1+2  i+2

---------------------------------------------------------------------------------
Lexer类中设计遇见的难点问题集合：
1. 发现在提取.sv文本内容的关键字时，所提取的第一行总是乱码垃圾值，而后面的文本可以正常提取与处理，在调试中发现确实没有任何操作去
修改存储.sv文本的内存，可是通过输出.sv文本的十六进制和所提取的.sv关键字的十六进制进行对比，发现确实不一样，而且仅第一行提取文本不一致，
后面内容却一致。
解决方案：虽然输出十六进制发现该第一行不一致，但是通过输出第二次的文本十六进制可以发现都被赋值为ffff，因此怀疑该前段内存被释放。
通常在一个变量在该作用域消失时才会被释放掉其内存，但考虑到本文本内容存放在名为FileData的结构体中，该结构体在整个程序生命周期中一直存在，
因此不应该是该结构体中的成员变量被释放的原因。因此考虑在为该结构体filememo成员复制时是否出的问题？定位到位filememo复制的语句中发现，我使用的
是string_view()进行复制，该string_view()是c++17中新加入的类，我一开始选用string_view是因为在了解c++17新特性时记得它比string在查找等一些方面
有一些优势，但忘记了string_view本质就是为字符串提供一个视图，可以通过该类的各种方法去观测该字符串，但它仅具有只读特性，并不真正持有该字符串，
不能像string一样可以用构造函数拷贝下来，但该视图所引用的字符串已被销毁时，那么对应的视图string_view也将失效。而我代码一开始所读取的文本内容放在
vector<char>这个局部容器变量中，将该局部容器变量赋值给string_view后，在容器作用域消失时，string_view也就失效，导致该内存被释放，释放时只有前面
呈现的效果时ffff，后面并没有清空，导致bug定位过久，蛊惑性较强。